<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Radio PTT WebRTC simple</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  select, button { margin: 5px; padding: 10px; font-size: 1rem; }
  #ptt { width: 200px; height: 50px; background: #2b2; color: white; border: none; border-radius: 5px; cursor: pointer; }
  #ptt.inactive { background: #555; cursor: not-allowed; }
</style>
</head>
<body>

<h2>Radio WebRTC PTT simple</h2>

<label for="audioIn">Micro (entrée) :</label>
<select id="audioIn"></select>

<label for="audioOut">Haut-parleur (sortie) :</label>
<select id="audioOut"></select>

<br>

<button id="join">Rejoindre la radio</button>
<br><br>
<button id="ptt" class="inactive" disabled>Appuyer pour parler</button>

<audio id="remoteAudio" autoplay></audio>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  // --- Firebase config à remplacer par le tien ---
  const firebaseConfig = {
    apiKey: "AIzaSyBPq6Wfxzq02MfK69BFxHm9_FUjDGTmAcw",
    authDomain: "kykychat-24c7f.firebaseapp.com",
    databaseURL: "https://kykychat-24c7f-default-rtdb.firebaseio.com",
    projectId: "kykychat-24c7f",
    storageBucket: "kykychat-24c7f.firebasestorage.app",
    messagingSenderId: "342562811927",
    appId: "1:342562811927:web:0fed1e1f511c4fddcfec52"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // DOM
  const audioInSelect = document.getElementById('audioIn');
  const audioOutSelect = document.getElementById('audioOut');
  const joinBtn = document.getElementById('join');
  const pttBtn = document.getElementById('ptt');
  const remoteAudio = document.getElementById('remoteAudio');

  let localStream = null;
  let pc = null;
  let isTalking = false;
  let currentUserId = null;

  // Pour limiter 1 personne qui parle à la fois
  let talkingUserId = null;

  // Buffer candidats ICE reçus avant setRemoteDescription
  let remoteCandidatesBuffer = [];

  // Préfixe Firebase pour signaux (à adapter selon la room)
  const roomName = 'radioRoom';
  const signalsRef = db.ref('signals/' + roomName);

  async function listAudioDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    audioInSelect.innerHTML = '';
    audioOutSelect.innerHTML = '';

    devices.forEach(device => {
      const option = document.createElement('option');
      option.value = device.deviceId;

      if(device.kind === 'audioinput'){
        option.text = device.label || `Microphone ${audioInSelect.length + 1}`;
        audioInSelect.appendChild(option);
      }
      else if(device.kind === 'audiooutput'){
        option.text = device.label || `Haut-parleur ${audioOutSelect.length + 1}`;
        audioOutSelect.appendChild(option);
      }
    });
  }

  function setAudioOutput(deviceId) {
    if(typeof remoteAudio.sinkId !== 'undefined'){
      remoteAudio.setSinkId(deviceId).catch(e => {
        console.warn('Erreur setSinkId:', e);
      });
    } else {
      console.warn('setSinkId non supporté par ce navigateur.');
    }
  }

  async function getLocalStream() {
    if(localStream){
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    const audioSource = audioInSelect.value;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: audioSource ? { exact: audioSource } : undefined } });
      localStream.getAudioTracks()[0].enabled = false;
      return localStream;
    } catch(e) {
      alert('Erreur accès micro : ' + e.message);
      throw e;
    }
  }

  function createPeerConnection() {
    const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
    const connection = new RTCPeerConnection(config);

    connection.onicecandidate = event => {
      if(event.candidate){
        signalsRef.child(currentUserId + '/ice').push(JSON.stringify(event.candidate));
      }
    };

    connection.ontrack = event => {
      const remoteStream = event.streams[0];
      applyRadioEffect(remoteStream);
    };

    return connection;
  }

  function applyRadioEffect(stream) {
    const audioCtx = new AudioContext();
    const source = audioCtx.createMediaStreamSource(stream);

    const biquadFilter = audioCtx.createBiquadFilter();
    biquadFilter.type = "bandpass";
    biquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime);

    const distortion = audioCtx.createWaveShaper();
    function makeDistortionCurve(amount = 20) {
      const n_samples = 44100;
      const curve = new Float32Array(n_samples);
      for(let i = 0; i < n_samples; ++i){
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + amount) * x * 20 * Math.PI / (Math.PI + amount * Math.abs(x));
      }
      return curve;
    }
    distortion.curve = makeDistortionCurve(15);
    distortion.oversample = '4x';

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.8;

    source.connect(biquadFilter);
    biquadFilter.connect(distortion);
    distortion.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    const dest = audioCtx.createMediaStreamDestination();
    gainNode.connect(dest);
    remoteAudio.srcObject = dest.stream;
  }

  function sendSignal(type, data) {
    signalsRef.child(currentUserId + '/' + type).push(data);
  }

  function listenSignals() {
    signalsRef.on('child_added', async snapshot => {
      const userId = snapshot.key;
      if(userId === currentUserId) return;

      const userSignalsRef = signalsRef.child(userId);

      userSignalsRef.child('offer').on('child_added', async snapOffer => {
        if(pc.signalingState === 'stable') {
          const offer = JSON.parse(snapOffer.val());
          await pc.setRemoteDescription(new RTCSessionDescription(offer));

          // Après setRemoteDescription, on traite le buffer des candidats
          for(const candidate of remoteCandidatesBuffer){
            try {
              await pc.addIceCandidate(candidate);
            } catch(e) {
              console.warn('Erreur addIceCandidate buffered:', e);
            }
          }
          remoteCandidatesBuffer = [];

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal('answer', JSON.stringify(pc.localDescription));
        }
      });

      userSignalsRef.child('answer').on('child_added', async snapAnswer => {
        const answer = JSON.parse(snapAnswer.val());
        await pc.setRemoteDescription(new RTCSessionDescription(answer));

        // Après setRemoteDescription, on traite le buffer des candidats
        for(const candidate of remoteCandidatesBuffer){
          try {
            await pc.addIceCandidate(candidate);
          } catch(e) {
            console.warn('Erreur addIceCandidate buffered:', e);
          }
        }
        remoteCandidatesBuffer = [];
      });

      userSignalsRef.child('ice').on('child_added', async snapIce => {
        const candidate = JSON.parse(snapIce.val());
        if(pc.remoteDescription && pc.remoteDescription.type){
          try {
            await pc.addIceCandidate(new RTCIceCandidate(candidate));
          } catch(e) {
            console.warn('Erreur addIceCandidate:', e);
          }
        } else {
          // Bufferiser si remoteDescription pas encore définie
          remoteCandidatesBuffer.push(new RTCIceCandidate(candidate));
        }
      });
    });
  }

  joinBtn.onclick = async () => {
    joinBtn.disabled = true;
    currentUserId = 'user' + Math.floor(Math.random()*1000000);

    localStream = await getLocalStream();

    pc = createPeerConnection();

    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    sendSignal('offer', JSON.stringify(pc.localDescription));

    listenSignals();

    pttBtn.disabled = false;
    pttBtn.classList.remove('inactive');
  };

  pttBtn.onpointerdown = () => {
    if(!localStream) return;
    if(talkingUserId && talkingUserId !== currentUserId){
      alert('Une autre personne parle, veuillez attendre.');
      return;
    }
    isTalking = true;
    talkingUserId = currentUserId;
    localStream.getAudioTracks()[0].enabled = true;
    pttBtn.style.backgroundColor = '#e33';
  };

  pttBtn.onpointerup = () => {
    if(!localStream) return;
    isTalking = false;
    talkingUserId = null;
    localStream.getAudioTracks()[0].enabled = false;
    pttBtn.style.backgroundColor = '#2b2';
  };

  audioInSelect.onchange = async () => {
    if(localStream){
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    if(pc){
      pc.close();
      pc = null;
    }
    joinBtn.disabled = false;
    pttBtn.disabled = true;
    pttBtn.classList.add('inactive');
  };

  audioOutSelect.onchange = () => {
    setAudioOutput(audioOutSelect.value);
  };

  listAudioDevices();

</script>


</body>
</html>

