<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Radio ATC Web</title>
    <style>
        body {
            background: black;
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .radio-container {
            display: inline-block;
            border: 2px solid #555;
            padding: 20px;
            margin-top: 50px;
        }
        .display {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 10px 0;
        }
        .freq-box {
            background: black;
            color: red;
            font-size: 30px;
            border: 2px solid white;
            width: 120px;
            margin: 0 10px;
        }
        .labels {
            display: flex;
            justify-content: center;
            font-size: 12px;
            margin-bottom: 5px;
        }
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .knob {
            width: 30px;
            height: 30px;
            background: #777;
            border-radius: 50%;
            margin: 0 5px;
            cursor: pointer;
        }
        .swap-btn {
            background: #333;
            color: white;
            border: 1px solid white;
            padding: 5px 10px;
            margin-left: 10px;
            cursor: pointer;
        }
        .device-select {
            margin: 20px 0;
        }
        .ptt-btn {
            background: red;
            color: white;
            font-size: 20px;
            padding: 15px 30px;
            margin-top: 20px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background 0.2s;
        }
        .ptt-btn.active {
            background: blue;
        }
        #pttBtn.active {
  background-color: #ff0000; /* rouge micro actif */
  box-shadow: 0 0 10px red;
}

#pttBtn.receiving {
  background-color: #00cc00; /* vert réception */
  box-shadow: 0 0 10px limegreen;
}

/* Si tu veux que rouge ET vert soient exclusifs */
#pttBtn.active.receiving {
  background-color: #ff0000; /* priorité rouge quand on parle */
}

    </style>
</head>
<body>

<h1>Radio ATC WebRTC</h1>

<div class="radio-container">
    <div class="labels">
        <div style="width: 120px;">ACTIVE</div>
        <div style="width: 120px;">STANDBY</div>
    </div>
    <div class="display">
        <div id="activeFreq" class="freq-box">118.00</div>
        <div id="standbyFreq" class="freq-box">121.50</div>
    </div>

    <div class="controls">
        <div class="knob" id="entierKnob"></div>
        <div class="knob" id="decimalKnob"></div>
        <button class="swap-btn" id="swapBtn">⇄</button>
    </div>
</div>

<div class="device-select">
    <label>Micro:</label>
    <select id="inputSelect"></select>
    <label>Haut-parleurs:</label>
    <select id="outputSelect"></select>
</div>

<button class="ptt-btn" id="pttBtn">PTT</button>

<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
<script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

<script>
// --- Firebase Config + init (idem) ---
const firebaseConfig = {
  apiKey: "AIzaSyBPq6Wfxzq02MfK69BFxHm9_FUjDGTmAcw",
  authDomain: "kykychat-24c7f.firebaseapp.com",
  databaseURL: "https://kykychat-24c7f-default-rtdb.firebaseio.com",
  projectId: "kykychat-24c7f",
  storageBucket: "kykychat-24c7f.firebasestorage.app",
  messagingSenderId: "342562811927",
  appId: "1:342562811927:web:0fed1e1f511c4fddcfec52"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

const roomName = "room";
const room = db.ref(roomName);

let localStream = null;
let myPseudo = null;
const connections = {}; // { pseudo: { pc, audioElement } }

const startBtn = document.getElementById("startBtn");
const pttBtn = document.getElementById("pttBtn");
const inputSelect = document.getElementById("inputSelect");   // Sélecteur micro
const outputSelect = document.getElementById("outputSelect"); // Sélecteur sortie audio

// Fonction pour obtenir le flux audio avec le deviceId choisi
async function getLocalStream(deviceId) {
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
  }
  try {
    const constraints = {
      audio: deviceId ? { deviceId: { exact: deviceId } } : true,
      video: false,
    };
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    localStream = stream;
    console.log("Micro activé avec deviceId:", deviceId);
  } catch (e) {
    alert("Erreur accès micro : " + e.message);
  }
}

// Remplir les sélecteurs input/output
async function updateDeviceLists() {
  const devices = await navigator.mediaDevices.enumerateDevices();

  // Input (micro)
  inputSelect.innerHTML = "";
  const audioInputs = devices.filter(d => d.kind === "audioinput");
  audioInputs.forEach(device => {
    const option = document.createElement("option");
    option.value = device.deviceId;
    option.text = device.label || `Microphone ${inputSelect.length + 1}`;
    inputSelect.appendChild(option);
  });

  // Output (enceinte / casque)
  outputSelect.innerHTML = "";
  const audioOutputs = devices.filter(d => d.kind === "audiooutput");
  audioOutputs.forEach(device => {
    const option = document.createElement("option");
    option.value = device.deviceId;
    option.text = device.label || `Sortie audio ${outputSelect.length + 1}`;
    outputSelect.appendChild(option);
  });
}

// Créer une connexion WebRTC à partir d'une offre
async function createConnection(pseudo, offerData, offerKey) {
  if (connections[pseudo]) return;

  const pc = new RTCPeerConnection();

  connections[pseudo] = { pc, audioElement: null };

  if (localStream) {
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
  }

  pc.ontrack = e => {
    if (!connections[pseudo].audioElement) {
      const audioEl = new Audio();
      audioEl.autoplay = true;
      if (outputSelect.value && audioEl.setSinkId) {
        audioEl.setSinkId(outputSelect.value).catch(console.warn);
      }
      connections[pseudo].audioElement = audioEl;
    }
    const audioEl = connections[pseudo].audioElement;
    audioEl.srcObject = e.streams[0];
    audioEl.play();

    detectIncomingVoice(audioEl);
  };

  pc.onicecandidate = event => {
    if (event.candidate) {
      room.child(offerKey).child("candidates").push({
        from: myPseudo,
        candidate: event.candidate.toJSON(),
      });
    }
  };

  await pc.setRemoteDescription(new RTCSessionDescription(offerData.offer));
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  await room.child(offerKey).update({ answer: pc.localDescription.toJSON() });
}

// Envoyer une offre
async function sendOffer() {
  if (!localStream) {
    alert("Micro non activé");
    return;
  }

  const offerKey = room.push().key;
  const pc = new RTCPeerConnection();

  connections["self"] = { pc, audioElement: null };

  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

  pc.onicecandidate = event => {
    if (event.candidate) {
      room.child(offerKey).child("candidates").push({
        from: myPseudo,
        candidate: event.candidate.toJSON(),
      });
    }
  };

  pc.ontrack = e => {
    // (Optionnel) Tu n'écoutes pas ton propre audio, donc rien ici
  };

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  await room.child(offerKey).set({
    offer: pc.localDescription.toJSON(),
    from: myPseudo,
  });

  // Écoute réponse answer
  room.child(offerKey).on("value", snapshot => {
    const data = snapshot.val();
    if (!data) return;
    if (data.answer && pc.signalingState !== "closed") {
      pc.setRemoteDescription(new RTCSessionDescription(data.answer));
    }
  });

  // Écoute candidates ICE
  room.child(offerKey).child("candidates").on("child_added", snap => {
    const cand = snap.val();
    if (cand.from !== myPseudo) {
      pc.addIceCandidate(new RTCIceCandidate(cand.candidate)).catch(console.warn);
    }
  });
}

// Écouter les offres entrantes
room.on("child_added", snap => {
  const offerData = snap.val();
  const offerKey = snap.key;

  if (offerData.from !== myPseudo && !connections[offerData.from]) {
    createConnection(offerData.from, offerData, offerKey);
  }
});

// Détection du son entrant sur un Audio element
function detectIncomingVoice(audioEl) {
  if (!audioEl) return;

  const audioCtx = new AudioContext();
  const source = audioCtx.createMediaStreamSource(audioEl.srcObject);
  const analyser = audioCtx.createAnalyser();
  analyser.fftSize = 256;
  source.connect(analyser);

  const dataArray = new Uint8Array(analyser.frequencyBinCount);

  let speakingTimeout = null;

  function checkVolume() {
    analyser.getByteFrequencyData(dataArray);
    let sum = 0;
    for (let i = 0; i < dataArray.length; i++) {
      sum += dataArray[i];
    }
    const average = sum / dataArray.length;

    if (average > 20) {
      pttBtn.style.backgroundColor = "limegreen";
      if (speakingTimeout) clearTimeout(speakingTimeout);
      speakingTimeout = setTimeout(() => {
        pttBtn.style.backgroundColor = "";
      }, 1500);
    }

    requestAnimationFrame(checkVolume);
  }

  checkVolume();
}

// Quand l'utilisateur change de micro, on relance le flux
inputSelect.addEventListener("change", async () => {
  await getLocalStream(inputSelect.value);

  // On met à jour les pistes sur chaque connexion ouverte
  Object.values(connections).forEach(({ pc }) => {
    // Enlever les anciennes pistes audio
    pc.getSenders().forEach(sender => {
      if (sender.track && sender.track.kind === "audio") {
        pc.removeTrack(sender);
      }
    });
    // Ajouter les nouvelles pistes
    localStream.getTracks().forEach(track => {
      if (track.kind === "audio") {
        pc.addTrack(track, localStream);
      }
    });
  });
});

// Quand l'utilisateur change de sortie audio, on met à jour les éléments Audio
outputSelect.addEventListener("change", () => {
  Object.values(connections).forEach(({ audioElement }) => {
    if (audioElement && audioElement.setSinkId) {
      audioElement.setSinkId(outputSelect.value).catch(console.warn);
    }
  });
});

async function init() {
  myPseudo = prompt("Entrez votre pseudo :");
  if (!myPseudo) {
    alert("Pseudo obligatoire");
    return;
  }

  await updateDeviceLists();
  await getLocalStream(inputSelect.value);

  startBtn.disabled = false;
  startBtn.addEventListener("click", () => {
    sendOffer();
  });
}

init();
</script>

</body>
</html>
