<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Radio PTT WebRTC simple</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  select, button { margin: 5px; padding: 10px; font-size: 1rem; }
  #ptt { width: 200px; height: 50px; background: #2b2; color: white; border: none; border-radius: 5px; cursor: pointer; }
  #ptt.inactive { background: #555; cursor: not-allowed; }
</style>
</head>
<body>

<h2>Radio WebRTC PTT simple</h2>

<label for="audioIn">Micro (entrée) :</label>
<select id="audioIn"></select>

<label for="audioOut">Haut-parleur (sortie) :</label>
<select id="audioOut"></select>

<br>

<button id="join">Rejoindre la radio</button>
<br><br>
<button id="ptt" class="inactive" disabled>Appuyer pour parler</button>

<audio id="remoteAudio" autoplay></audio>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  // --- Firebase config à remplacer par le tien ---
  const firebaseConfig = {
    apiKey: "TON_API_KEY",
    authDomain: "TON_PROJET.firebaseapp.com",
    databaseURL: "https://TON_PROJET-default-rtdb.firebaseio.com",
    projectId: "TON_PROJET",
    storageBucket: "TON_PROJET.appspot.com",
    messagingSenderId: "TON_SENDER_ID",
    appId: "TON_APP_ID"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // DOM
  const audioInSelect = document.getElementById('audioIn');
  const audioOutSelect = document.getElementById('audioOut');
  const joinBtn = document.getElementById('join');
  const pttBtn = document.getElementById('ptt');
  const remoteAudio = document.getElementById('remoteAudio');

  let localStream = null;
  let pc = null;
  let isTalking = false;
  let currentUserId = null;

  // Pour limiter 1 personne qui parle à la fois
  let talkingUserId = null;

  // Préfixe Firebase pour signaux (à adapter selon la room)
  const roomName = 'radioRoom';
  const signalsRef = db.ref('signals/' + roomName);

  // Fonction pour lister les périphériques audio
  async function listAudioDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    audioInSelect.innerHTML = '';
    audioOutSelect.innerHTML = '';

    devices.forEach(device => {
      const option = document.createElement('option');
      option.value = device.deviceId;

      if(device.kind === 'audioinput'){
        option.text = device.label || `Microphone ${audioInSelect.length + 1}`;
        audioInSelect.appendChild(option);
      }
      else if(device.kind === 'audiooutput'){
        option.text = device.label || `Haut-parleur ${audioOutSelect.length + 1}`;
        audioOutSelect.appendChild(option);
      }
    });
  }

  // Appliquer le périphérique de sortie audio
  function setAudioOutput(deviceId) {
    if(typeof remoteAudio.sinkId !== 'undefined'){
      remoteAudio.setSinkId(deviceId).catch(e => {
        console.warn('Erreur setSinkId:', e);
      });
    } else {
      console.warn('setSinkId non supporté par ce navigateur.');
    }
  }

  // Obtenir le flux audio local selon la sélection
  async function getLocalStream() {
    if(localStream){
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    const audioSource = audioInSelect.value;
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: { deviceId: audioSource ? { exact: audioSource } : undefined } });
      // Initialement mute, on parle seulement quand PTT est appuyé
      localStream.getAudioTracks()[0].enabled = false;
      return localStream;
    } catch(e) {
      alert('Erreur accès micro : ' + e.message);
      throw e;
    }
  }

  // Créer un RTCPeerConnection avec gestion ICE
  function createPeerConnection() {
    const config = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };
    const connection = new RTCPeerConnection(config);

    connection.onicecandidate = event => {
      if(event.candidate){
        signalsRef.child(currentUserId + '/ice').push(JSON.stringify(event.candidate));
      }
    };

    connection.ontrack = event => {
      // On va appliquer un effet audio radio ici
      const remoteStream = event.streams[0];
      applyRadioEffect(remoteStream);
    };

    return connection;
  }

  // Appliquer un effet radio simple avec Web Audio API
  function applyRadioEffect(stream) {
    const audioCtx = new AudioContext();
    const source = audioCtx.createMediaStreamSource(stream);

    // Baisser les basses, augmenter les médiums et un peu de distorsion
    const biquadFilter = audioCtx.createBiquadFilter();
    biquadFilter.type = "bandpass";
    biquadFilter.frequency.setValueAtTime(1000, audioCtx.currentTime); // fréquence centrée vers médiums

    const distortion = audioCtx.createWaveShaper();
    function makeDistortionCurve(amount = 20) {
      const n_samples = 44100;
      const curve = new Float32Array(n_samples);
      for(let i = 0; i < n_samples; ++i){
        const x = i * 2 / n_samples - 1;
        curve[i] = (3 + amount) * x * 20 * Math.PI / (Math.PI + amount * Math.abs(x));
      }
      return curve;
    }
    distortion.curve = makeDistortionCurve(15);
    distortion.oversample = '4x';

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.8;

    source.connect(biquadFilter);
    biquadFilter.connect(distortion);
    distortion.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    // connecter à l'élément audio HTML
    const dest = audioCtx.createMediaStreamDestination();
    gainNode.connect(dest);
    remoteAudio.srcObject = dest.stream;
  }

  // Envoie un message signal via Firebase
  function sendSignal(type, data) {
    signalsRef.child(currentUserId + '/' + type).push(data);
  }

  // Ecoute des signaux entrants des autres
  function listenSignals() {
    signalsRef.on('child_added', async snapshot => {
      const userId = snapshot.key;
      if(userId === currentUserId) return; // ignorer soi-même

      const userSignalsRef = signalsRef.child(userId);

      // On écoute les offres, réponses et ICE du remote
      userSignalsRef.child('offer').on('child_added', async snapOffer => {
        if(pc.signalingState === 'stable') {
          const offer = JSON.parse(snapOffer.val());
          await pc.setRemoteDescription(new RTCSessionDescription(offer));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          sendSignal('answer', JSON.stringify(pc.localDescription));
        }
      });

      userSignalsRef.child('answer').on('child_added', async snapAnswer => {
        const answer = JSON.parse(snapAnswer.val());
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
      });

      userSignalsRef.child('ice').on('child_added', async snapIce => {
        const candidate = JSON.parse(snapIce.val());
        try {
          await pc.addIceCandidate(new RTCIceCandidate(candidate));
        } catch(e) {
          console.warn('Erreur addIceCandidate:', e);
        }
      });
    });
  }

  // Initialisation et join
  joinBtn.onclick = async () => {
    joinBtn.disabled = true;
    currentUserId = 'user' + Math.floor(Math.random()*1000000);

    localStream = await getLocalStream();

    pc = createPeerConnection();

    // Ajouter piste audio locale au peer connection
    localStream.getTracks().forEach(track => {
      pc.addTrack(track, localStream);
    });

    // Create offer
    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    sendSignal('offer', JSON.stringify(pc.localDescription));

    listenSignals();

    pttBtn.disabled = false;
    pttBtn.classList.remove('inactive');
  };

  // PTT bouton: activer/désactiver audio local
  pttBtn.onpointerdown = () => {
    if(!localStream) return;
    if(talkingUserId && talkingUserId !== currentUserId){
      alert('Une autre personne parle, veuillez attendre.');
      return;
    }
    isTalking = true;
    talkingUserId = currentUserId;
    localStream.getAudioTracks()[0].enabled = true;
    pttBtn.style.backgroundColor = '#e33';
  };

  pttBtn.onpointerup = () => {
    if(!localStream) return;
    isTalking = false;
    talkingUserId = null;
    localStream.getAudioTracks()[0].enabled = false;
    pttBtn.style.backgroundColor = '#2b2';
  };

  // Sélecteurs de périphériques
  audioInSelect.onchange = async () => {
    if(localStream){
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    if(pc){
      pc.close();
      pc = null;
    }
    joinBtn.disabled = false;
    pttBtn.disabled = true;
    pttBtn.classList.add('inactive');
  };

  audioOutSelect.onchange = () => {
    setAudioOutput(audioOutSelect.value);
  };

  // Au chargement, liste les devices
  listAudioDevices();

</script>

</body>
</html>

