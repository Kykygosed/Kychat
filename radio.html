<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Radio PTT WebRTC simple</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; }
  select, button { margin: 5px; padding: 10px; font-size: 1rem; }
  #ptt { width: 200px; height: 50px; background: #2b2; color: white; border: none; border-radius: 5px; cursor: pointer; }
  #ptt.inactive { background: #555; cursor: not-allowed; }
</style>
</head>
<body>

<h2>Radio WebRTC PTT simple</h2>

<label for="audioIn">Micro (entrée) :</label>
<select id="audioIn"></select>

<label for="audioOut">Haut-parleur (sortie) :</label>
<select id="audioOut"></select>

<br>

<button id="join">Rejoindre la radio</button>
<br><br>
<button id="ptt" class="inactive" disabled>Appuyer pour parler</button>

<audio id="remoteAudio" autoplay></audio>

<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getDatabase, ref, onValue, set, push, get, remove, onChildAdded } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";

const firebaseConfig = {
    apiKey: "AIzaSyDDH3yMEr78C_h0yAMiEXYVtENmiwMbxas",
    authDomain: "kykychat-24c7f.firebaseapp.com",
    databaseURL: "https://kykychat-24c7f-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "kykychat-24c7f",
    storageBucket: "kykychat-24c7f.appspot.com",
    messagingSenderId: "248801360563",
    appId: "1:248801360563:web:bdd019dd49805236c84310"
};

const app = initializeApp(firebaseConfig);
const db = getDatabase(app);

const currentUserId = prompt('Enter your callsign:');
const localAudio = document.getElementById('localAudio');
const remoteAudio = document.getElementById('remoteAudio');
const pttBtn = document.getElementById('pttBtn');
const talkingRef = ref(db, 'radioRoom/talking');

let localStream;
let peerConnections = {}; // Gestion multi-connexions
let currentRemoteUserId = null;

// Obtenir le flux audio local
navigator.mediaDevices.getUserMedia({ audio: true })
    .then(stream => {
        localStream = stream;
        localAudio.srcObject = stream;

        // Mute par défaut
        localStream.getAudioTracks().forEach(track => {
            track.enabled = false;
        });

        // Annoncer sa présence
        const userRef = ref(db, `radioRoom/users/${currentUserId}`);
        set(userRef, true);

        // Gestion des nouveaux utilisateurs
        onValue(ref(db, 'radioRoom/users'), snapshot => {
            const users = snapshot.val() || {};
            Object.keys(users).forEach(userId => {
                if (userId !== currentUserId && !peerConnections[userId]) {
                    console.log('Connexion à :', userId);
                    startConnection(userId);
                }
            });
        });
    })
    .catch(error => console.error('Erreur d’accès au micro :', error));

// Fonction pour démarrer une connexion WebRTC
function startConnection(remoteUserId) {
    currentRemoteUserId = remoteUserId;

    const peerConnection = new RTCPeerConnection();
    peerConnections[remoteUserId] = peerConnection;

    // Ajouter les pistes audio locales
    localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
    });

    // Gestion ICE
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            push(ref(db, `radioRoom/candidates/${remoteUserId}/${currentUserId}`), JSON.stringify(event.candidate));
        }
    };

    // Réception des flux distants
    peerConnection.ontrack = event => {
        console.log('Flux reçu de', remoteUserId);
        remoteAudio.srcObject = event.streams[0];
    };

    // Écoute des candidats entrants
    onChildAdded(ref(db, `radioRoom/candidates/${currentUserId}/${remoteUserId}`), snapshot => {
        const candidate = JSON.parse(snapshot.val());
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    });

    // Signaling offer/answer
    createOffer(remoteUserId, peerConnection);
}

// Création de l’offre
async function createOffer(remoteUserId, peerConnection) {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    set(ref(db, `radioRoom/offers/${remoteUserId}`), {
        from: currentUserId,
        sdp: offer.sdp
    });
}

// Réception d’offre et création de l’answer
onValue(ref(db, `radioRoom/offers/${currentUserId}`), async snapshot => {
    const offerData = snapshot.val();
    if (!offerData) return;

    const remoteUserId = offerData.from;

    if (peerConnections[remoteUserId]) return;

    console.log('Réception offre de', remoteUserId);

    const peerConnection = new RTCPeerConnection();
    peerConnections[remoteUserId] = peerConnection;

    // Ajouter les pistes locales
    localStream.getTracks().forEach(track => {
        peerConnection.addTrack(track, localStream);
    });

    // Gestion ICE
    peerConnection.onicecandidate = event => {
        if (event.candidate) {
            push(ref(db, `radioRoom/candidates/${remoteUserId}/${currentUserId}`), JSON.stringify(event.candidate));
        }
    };

    // Réception du flux distant
    peerConnection.ontrack = event => {
        console.log('Flux reçu de', remoteUserId);
        remoteAudio.srcObject = event.streams[0];
    };

    // Écoute des candidats entrants
    onChildAdded(ref(db, `radioRoom/candidates/${currentUserId}/${remoteUserId}`), snapshot => {
        const candidate = JSON.parse(snapshot.val());
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    });

    await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: offerData.sdp }));

    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    set(ref(db, `radioRoom/answers/${remoteUserId}`), {
        from: currentUserId,
        sdp: answer.sdp
    });
});

// Réception de l’answer
onValue(ref(db, `radioRoom/answers/${currentUserId}`), async snapshot => {
    const answerData = snapshot.val();
    if (!answerData) return;

    const remoteUserId = answerData.from;
    const peerConnection = peerConnections[remoteUserId];

    if (!peerConnection.currentRemoteDescription) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: answerData.sdp }));
        console.log('Answer reçue de', remoteUserId);
    }
});

// Gestion PTT
pttBtn.onpointerdown = () => {
    if (!localStream) return;

    talkingRef.once('value').then(snapshot => {
        const currentSpeaker = snapshot.val();
        if (currentSpeaker && currentSpeaker !== currentUserId) {
            alert('Une autre personne parle, veuillez attendre.');
            return;
        }

        talkingRef.set(currentUserId);

        localStream.getAudioTracks().forEach(track => {
            track.enabled = true;
        });

        pttBtn.style.backgroundColor = '#e33';
    });
};

pttBtn.onpointerup = () => {
    if (!localStream) return;

    talkingRef.once('value').then(snapshot => {
        if (snapshot.val() === currentUserId) {
            talkingRef.set(null);
        }
    });

    localStream.getAudioTracks().forEach(track => {
        track.enabled = false;
    });

    pttBtn.style.backgroundColor = '#2b2';
};

</script>



</body>
</html>

