<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Radio WebRTC PTT with Firebase</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #eee;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
  }
  select, button {
    margin: 5px;
    font-size: 1.1em;
    padding: 8px 12px;
    border-radius: 5px;
    border: none;
    outline: none;
  }
  button {
    cursor: pointer;
  }
  button:active {
    background-color: #44bb44;
    color: white;
  }
  #status {
    margin: 10px;
    font-weight: bold;
  }
  #ptt {
    font-size: 2em;
    padding: 20px 40px;
    background: #222;
    border: 2px solid #555;
    border-radius: 10px;
    user-select: none;
  }
  #ptt.active {
    background: #bb2222;
    border-color: #ff5555;
    color: white;
  }
</style>
</head>
<body>

<h1>Radio WebRTC PTT</h1>

<div>
  <label>Microphone : </label>
  <select id="inputSelect"></select>
</div>
<div>
  <label>Sortie audio : </label>
  <select id="outputSelect"></select>
</div>

<button id="startStop">Activer Micro</button>
<div id="status">Micro désactivé. Personne ne parle.</div>

<button id="ptt" disabled>Appuie et maintiens pour parler</button>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<script>
  // --- CONFIG FIREBASE --- 
const firebaseConfig = {
  apiKey: "AIzaSyDyWu4TI4PIRXfeb7yqt0WIGClgu10IjkM",
  authDomain: "kylita-f2923.firebaseapp.com",
  projectId: "kylita-f2923",
  storageBucket: "kylita-f2923.appspot.com",
  messagingSenderId: "431823530994",
  appId: "1:431823530994:web:88a07e633751686e5ad96b",
  measurementId: "G-F4LLNWQJ16",
  databaseURL: "https://kylita-f2923-default-rtdb.firebaseio.com"
};
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

  // --- VARIABLES GLOBALES ---
  const inputSelect = document.getElementById('inputSelect');
  const outputSelect = document.getElementById('outputSelect');
  const startStopBtn = document.getElementById('startStop');
  const pttBtn = document.getElementById('ptt');
  const statusText = document.getElementById('status');

  let localStream = null;
  let localAudioTrack = null;
  let audioContext = null;
  let destinationNode = null;
  let radioFilterNode = null;
  let outputAudio = new Audio();
  let userId = 'user_' + Math.floor(Math.random() * 1000000);
  let speaking = false;

  // WebRTC variables
  let peers = {};
  let localConnection = null;
  let signalingRef = db.ref('radio_signaling');
  let talkerRef = db.ref('radio_talker');
  let usersRef = db.ref('radio_users');

  // --- Fonctions ---
  async function listDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();

    // Clear selects
    inputSelect.innerHTML = '';
    outputSelect.innerHTML = '';

    devices.forEach(d => {
      const option = document.createElement('option');
      option.value = d.deviceId;
      option.text = d.label || (d.kind === 'audioinput' ? 'Microphone' : 'Haut-parleur');
      if (d.kind === 'audioinput') {
        inputSelect.appendChild(option);
      } else if (d.kind === 'audiooutput') {
        outputSelect.appendChild(option);
      }
    });
  }

  async function getLocalStream() {
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    const constraints = {
      audio: {
        deviceId: inputSelect.value ? {exact: inputSelect.value} : undefined
      }
    };
    try {
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      localAudioTrack = localStream.getAudioTracks()[0];
      pttBtn.disabled = false;
      statusText.textContent = "Micro activé, prêt à parler.";
    } catch(e) {
      alert("Erreur accès micro : " + e.message);
      pttBtn.disabled = true;
    }
  }

  // Fonction pour appliquer effet radio à un MediaStreamAudioSourceNode
  function createRadioFilter(audioCtx, sourceNode) {
    // Exemple : un filtre bandpass étroit, un peu de distorsion, et un EQ basique
    const bandpass = audioCtx.createBiquadFilter();
    bandpass.type = 'bandpass';
    bandpass.frequency.value = 1000;
    bandpass.Q.value = 10;

    const distortion = audioCtx.createWaveShaper();
    distortion.curve = makeDistortionCurve(400);
    distortion.oversample = '4x';

    const gainNode = audioCtx.createGain();
    gainNode.gain.value = 0.8;

    sourceNode.connect(bandpass);
    bandpass.connect(distortion);
    distortion.connect(gainNode);

    return gainNode;
  }

  function makeDistortionCurve(amount) {
    const k = typeof amount === 'number' ? amount : 50;
    const n_samples = 44100;
    const curve = new Float32Array(n_samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < n_samples; ++i ) {
      const x = i * 2 / n_samples - 1;
      curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
    }
    return curve;
  }

  function setupAudioContext() {
    if (audioContext) audioContext.close();
    audioContext = new AudioContext();

    destinationNode = audioContext.createMediaStreamDestination();
  }

  // Setup output audio device
  function setOutputDevice(deviceId) {
    if (typeof outputAudio.setSinkId !== 'undefined') {
      outputAudio.setSinkId(deviceId)
      .then(() => {
        console.log("Sortie audio définie : " + deviceId);
      })
      .catch(e => console.warn("Erreur setSinkId:", e));
    } else {
      console.warn("setSinkId non supporté par ce navigateur");
    }
  }

  // --- SIGNALISATION / WEBSOCKET (via Firebase) ---
  // On stocke dans firebase les offres/answers/ICE candidates entre peers
  // Ici on fait un mesh simple, chaque nouvel utilisateur crée une peer connection avec tous les autres

  // Référence aux users connectés
  let users = {};
  let isTalking = false;

  async function createPeerConnection(peerId, isOfferer) {
    const pc = new RTCPeerConnection({
      iceServers: [{urls:'stun:stun.l.google.com:19302'}]
    });

    // Ajout du stream local (uniquement si micro activé)
    if (localStream) {
      localStream.getTracks().forEach(track => {
        pc.addTrack(track, localStream);
      });
    }

    pc.onicecandidate = (event) => {
      if (event.candidate) {
        const candRef = db.ref(`radio_signaling/${userId}/${peerId}/candidates`);
        candRef.push(event.candidate.toJSON());
      }
    };

    pc.ontrack = (event) => {
      // Ici on reçoit le stream de l'autre utilisateur
      const remoteStream = event.streams[0];
      playRemoteStream(peerId, remoteStream);
    };

    if (isOfferer) {
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      await db.ref(`radio_signaling/${userId}/${peerId}/offer`).set(pc.localDescription.toJSON());
    }

    // Ecoute answer et candidats venant du peer
    db.ref(`radio_signaling/${peerId}/${userId}`).on('value', async snapshot => {
      const data = snapshot.val();
      if (!data) return;

      if (data.answer && !pc.currentRemoteDescription) {
        const answerDesc = new RTCSessionDescription(data.answer);
        await pc.setRemoteDescription(answerDesc);
      }

      if (data.candidates) {
        Object.values(data.candidates).forEach(async cand => {
          try {
            await pc.addIceCandidate(new RTCIceCandidate(cand));
          } catch (e) {
            console.warn('addIceCandidate error', e);
          }
        });
      }
    });

    return pc;
  }

  // Jouer le son de l'autre avec effet radio
  function playRemoteStream(peerId, stream) {
    // Crée un audio context si nécessaire
    if (!audioContext) setupAudioContext();

    const source = audioContext.createMediaStreamSource(stream);
    const filtered = createRadioFilter(audioContext, source);

    filtered.connect(destinationNode);

    outputAudio.srcObject = destinationNode.stream;
    outputAudio.play();

    // Garde la référence pour cleanup si besoin (non implémenté ici)
  }

  // Gérer la liste users connectés dans Firebase
  usersRef.child(userId).set({online: true});
  usersRef.child(userId).onDisconnect().remove();

  // Surveillance de qui parle (talker)
  talkerRef.on('value', snap => {
    const talker = snap.val();
    if (!talker) {
      statusText.textContent = "Micro activé, personne ne parle.";
      pttBtn.disabled = false;
    } else if (talker === userId) {
      statusText.textContent = "Tu parles.";
      pttBtn.classList.add('active');
      pttBtn.disabled = false;
      isTalking = true;
    } else {
      statusText.textContent = `L'utilisateur ${talker} parle.`;
      pttBtn.disabled = true;
      pttBtn.classList.remove('active');
      isTalking = false;
    }
  });

  // Start/Stop micro
  startStopBtn.onclick = async () => {
    if (!localStream) {
      await getLocalStream();
      startStopBtn.textContent = "Désactiver Micro";
      await connectToPeers();
    } else {
      stopLocalStream();
      startStopBtn.textContent = "Activer Micro";
      pttBtn.disabled = true;
    }
  };

  function stopLocalStream() {
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
      localAudioTrack = null;
    }
    // Quitter la parole si on était en train de parler
    if (isTalking) {
      talkerRef.set(null);
    }
  }

  // Connecter aux autres users (mesh simple)
  async function connectToPeers() {
    // Récupère la liste des users en ligne sauf toi
    const snapshot = await usersRef.get();
    users = snapshot.val() || {};

    for (const otherUserId in users) {
      if (otherUserId !== userId && !peers[otherUserId]) {
        const pc = await createPeerConnection(otherUserId, true);
        peers[otherUserId] = pc;
      }
    }

    // Ecoute les offres venant des autres pour créer la connexion
    signalingRef.child(userId).on('child_added', async snap => {
      const fromUser = snap.key;
      if (fromUser === userId) return;

      if (!peers[fromUser]) {
        const pc = await createPeerConnection(fromUser, false);
        peers[fromUser] = pc;
      }
    });
  }

  // PTT - Push To Talk
  pttBtn.onpointerdown = async () => {
    if (isTalking) return; // tu parles déjà

    const talker = (await talkerRef.get()).val();
    if (!talker) {
      await talkerRef.set(userId);
      pttBtn.classList.add('active');
      isTalking = true;
      statusText.textContent = "Tu parles.";
    } else {
      alert("Quelqu'un parle déjà !");
    }
  };

  pttBtn.onpointerup = async () => {
    if (isTalking) {
      await talkerRef.set(null);
      pttBtn.classList.remove('active');
      isTalking = false;
      statusText.textContent = "Micro activé, personne ne parle.";
    }
  };

  // Sélecteurs périphériques
  inputSelect.onchange = async () => {
    if (localStream) {
      await getLocalStream();
      // TODO : mettre à jour la piste audio sur les PeerConnections ?
      // (Plus complexe, hors scope simple ici)
    }
  };

  outputSelect.onchange = () => {
    setOutputDevice(outputSelect.value);
  };

  // Init
  listDevices();

  // Fix pour que le user change périphériques
  navigator.mediaDevices.ondevicechange = () => {
    listDevices();
  };

</script>

</body>
</html>

